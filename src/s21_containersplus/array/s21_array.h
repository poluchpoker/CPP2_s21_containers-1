#ifndef S21_CONTAINERS_SRC_S21_CONTAINERSPLUS_ARRAY_S21_ARRAY_H
#define S21_CONTAINERS_SRC_S21_CONTAINERSPLUS_ARRAY_S21_ARRAY_H

#include <algorithm>
#include <initializer_list>
#include <stdexcept>

namespace s21 {

/**
 * @file s21_array.h
 * @brief Определение шаблонного класса array, реализующего контейнер
 * фиксированного размера.
 *
 * @author s21
 * @date 2024-04-27
 *
 * @tparam T Тип элементов, хранящихся в массиве.
 * @tparam N Размер массива.
 *
 * @details Класс `array` представляет собой шаблонный контейнер фиксированного
 * размера, реализованный в пространстве имен `s21`. Он предоставляет
 * функциональность для работы с массивом фиксированного размера, включая доступ
 * к элементам, итераторы, а также операции, такие как копирование, перемещение
 * и обмен содержимым.
 *
 * Класс `array` поддерживает все основные операции, доступные для стандартных
 * контейнеров в C++, такие как доступ к элементам через операторы `[]` и `at`,
 * получение итераторов на начало и конец контейнера, а также проверку на
 * пустоту и получение размера.
 *
 * @note В отличие от стандартного контейнера `std::array`, класс `array` в
 * данном файле реализует дополнительные методы, такие как `front`, `back`,
 * `swap` и `fill`, а также предоставляет возможность обмена содержимым с другим
 * массивом через метод `swap`.
 */
template <typename T, std::size_t N>
class array {
 public:
  using value_type = T;
  using reference = T &;
  using const_reference = const T &;
  using iterator = T *;
  using const_iterator = const T *;
  using size_type = std::size_t;

 public:
  /**
   * @brief Конструктор по умолчанию.
   *
   * Создаёт экземпляр класса `array` без инициализации элементов.
   */
  array() noexcept = default;

  /**
   * @brief Конструктор с инициализацией списком.
   *
   * @param items Список инициализации.
   *
   * Создаёт экземпляр класса `array` и инициализирует его элементы значениями
   * из списка.
   */
  array(std::initializer_list<value_type> const &items) {
    std::copy(items.begin(), items.end(), data_);
  }

  /**
   * @brief Конструктор копирования.
   *
   * @param a Объект для копирования.
   *
   * Создаёт новый экземпляр класса `array`, копируя элементы из другого
   * объекта.
   */
  array(const array &a) noexcept { std::copy(a.data_, a.data_ + N, data_); }

  /**
   * @brief Конструктор перемещения.
   *
   * @param a Объект для перемещения.
   *
   * Создаёт новый экземпляр класса `array`, перемещая элементы из другого
   * объекта.
   */
  array(array &&a) noexcept { std::move(a.data_, a.data_ + N, data_); }

  /**
   * @brief Дестркутор по умолчанию.
   */
  ~array() noexcept {}

  /**
   * @brief Оператор присваивания перемещением.
   *
   * @param a Объект для перемещения.
   * @return Ссылку на текущий объект.
   *
   * Перемещает элементы из другого объекта в текущий объект.
   */
  array &operator=(array &&a) {
    if (this != &a) {
      for (size_type index = 0; index < N; ++index)
        data_[index] = std::move(a.data_[index]);
    }

    return *this;
  }

 public:
  /**
   * @brief Доступ к элементу по индексу.
   *
   * @param pos Индекс элемента.
   * @return Ссылку на элемент.
   *
   * Возвращает ссылку на элемент по указанному индексу.
   * Генерирует исключение `std::out_of_range`, если индекс выходит за пределы
   * допустимого диапазона.
   */
  reference at(size_type pos) {
    if (pos >= N)
      throw std::out_of_range(
          "Переданная позиция выходит за пределы допустимого диапазона");

    return data_[pos];
  }

  /**
   * @brief Доступ к элементу по индексу (константная версия).
   *
   * @param pos Индекс элемента.
   * @return Константную ссылку на элемент.
   *
   * Возвращает константную ссылку на элемент по указанному индексу.
   * Генерирует исключение `std::out_of_range`, если индекс выходит за пределы
   * допустимого диапазона.
   */
  constexpr const_reference at(size_type pos) const {
    if (pos >= N)
      throw std::out_of_range(
          "Переданная позиция выходит за пределы допустимого диапазона");

    return data_[pos];
  }

  /**
   * @brief Доступ к элементу по индексу.
   *
   * @param pos Индекс элемента.
   * @return Ссылку на элемент.
   *
   * Оператор `operator[]` предоставляет доступ к элементу массива по указанному
   * индексу. Он использует метод `at` для проверки допустимости индекса и
   * возвращает ссылку на элемент.
   *
   * @note В отличие от метода `at`, `operator[]` не генерирует исключение
   * `std::out_of_range`, если индекс выходит за пределы допустимого диапазона.
   * Это может привести к неопределенному поведению.
   */
  constexpr reference operator[](size_type pos) { return at(pos); }

  /**
   * @brief Доступ к элементу по индексу (константная версия).
   *
   * @param pos Индекс элемента.
   * @return Константную ссылку на элемент.
   *
   * Константная версия оператора `operator[]` предоставляет доступ к элементу
   * массива по указанному индексу без возможности изменения его значения. Она
   * также использует метод `at` для проверки допустимости индекса и возвращает
   * константную ссылку на элемент.
   *
   * @note В отличие от метода `at`, `operator[]` не генерирует исключение
   * `std::out_of_range`, если индекс выходит за пределы допустимого диапазона.
   * Это может привести к неопределенному поведению.
   */
  constexpr const_reference operator[](size_type pos) const { return at(pos); }

  /**
   * @brief Доступ к первому элементу массива.
   *
   * @return Ссылку на первый элемент.
   *
   * Метод `front` возвращает ссылку на первый элемент массива.
   * Генерирует исключение `std::out_of_range`, если размер массива равен нулю,
   * так как в этом случае нет элементов для доступа.
   */
  constexpr reference front() {
    if (N == 0)
      throw std::out_of_range(
          "Использование методов на контейнере с нулевым размером приводит к "
          "неопределенному поведению.");

    return data_[0];
  }

  /**
   * @brief Доступ к первому элементу массива (константная версия).
   *
   * @return Константную ссылку на первый элемент.
   *
   * Константная версия метода `front` возвращает константную ссылку на первый
   * элемент массива. Генерирует исключение `std::out_of_range`, если размер
   * массива равен нулю, так как в этом случае нет элементов для доступа.
   */
  constexpr const_reference front() const {
    if (N == 0)
      throw std::out_of_range(
          "Использование методов на контейнере с нулевым размером приводит к "
          "неопределенному поведению.");

    return data_[0];
  }

  /**
   * @brief Доступ к последнему элементу массива.
   *
   * @return Ссылку на последний элемент.
   *
   * Метод `back` возвращает ссылку на последний элемент массива.
   * Генерирует исключение `std::out_of_range`, если размер массива равен нулю,
   * так как в этом случае нет элементов для доступа.
   */
  constexpr reference back() {
    if (N == 0)
      throw std::out_of_range(
          "Использование методов на контейнере с нулевым размером приводит к "
          "неопределенному поведению.");

    return data_[N - 1];
  }

  /**
   * @brief Доступ к последнему элементу массива (константная версия).
   *
   * @return Константную ссылку на последний элемент.
   *
   * Константная версия метода `back` возвращает константную ссылку на последний
   * элемент массива. Генерирует исключение `std::out_of_range`, если размер
   * массива равен нулю, так как в этом случае нет элементов для доступа.
   */
  constexpr const_reference back() const {
    if (N == 0)
      throw std::out_of_range(
          "Использование методов на контейнере с нулевым размером приводит к "
          "неопределенному поведению.");

    return data_[N - 1];
  }

  /**
   * @brief Получение итератора на начало массива.
   *
   * @return Итератор на начало массива.
   *
   * Метод `data` возвращает итератор, указывающий на первый элемент массива.
   * Этот метод позволяет получить прямой доступ к данным массива, что может
   * быть полезно для интеграции с функциями, работающими с C-style массивами
   * или для оптимизации производительности.
   */
  constexpr iterator data() noexcept { return data_; }

  /**
   * @brief Получение итератора на начало массива (константная версия).
   *
   * @return Константный итератор на начало массива.
   *
   * Константная версия метода `data` возвращает константный итератор,
   * указывающий на первый элемент массива. Это позволяет безопасно
   * просматривать данные массива без их изменения.
   */
  constexpr const_iterator data() const noexcept { return data_; }

 public:
  /**
   * @brief Получение итератора на начало массива.
   *
   * @return Итератор на начало массива.
   *
   * Метод `begin` возвращает итератор, указывающий на первый элемент массива.
   * Этот метод позволяет начать итерацию по элементам массива.
   *
   * @note Итератор, возвращаемый этим методом, является двунаправленным, что
   * позволяет использовать его для обхода массива в обоих направлениях.
   */
  constexpr iterator begin() noexcept { return data_; }

  /**
   * @brief Получение итератора на начало массива (константная версия).
   *
   * @return Константный итератор на начало массива.
   *
   * Константная версия метода `begin` возвращает константный итератор,
   * указывающий на первый элемент массива. Это позволяет безопасно
   * просматривать данные массива без их изменения.
   */
  constexpr const_iterator begin() const noexcept { return data_; }

  /**
   * @brief Получение итератора на конец массива.
   *
   * @return Итератор на конец массива.
   *
   * Метод `end` возвращает итератор, указывающий на элемент, следующий за
   * последним элементом массива. Этот метод используется для определения конца
   * итерации по элементам массива.
   *
   * @note Итератор, возвращаемый этим методом, является двунаправленным, что
   * позволяет использовать его для обхода массива в обоих направлениях.
   */
  constexpr iterator end() noexcept { return data_ + N; }

  /**
   * @brief Получение итератора на конец массива (константная версия).
   *
   * @return Константный итератор на конец массива.
   *
   * Константная версия метода `end` возвращает константный итератор,
   * указывающий на элемент, следующий за последним элементом массива. Это
   * позволяет безопасно просматривать данные массива без их изменения.
   */
  constexpr const_iterator end() const noexcept { return data_ + N; }

 public:
  /**
   * @brief Проверка на пустоту массива.
   *
   * @return `true`, если массив пуст, и `false` в противном случае.
   *
   * Метод `empty` возвращает `true`, если размер массива равен нулю, и `false`
   * в противном случае. Этот метод позволяет быстро проверить, содержит ли
   * массив какие-либо элементы.
   */
  constexpr bool empty() const noexcept { return !size_; }

  /**
   * @brief Получение размера массива.
   *
   * @return Размер массива.
   *
   * Метод `size` возвращает количество элементов в массиве.
   * Этот метод предоставляет информацию о текущем количестве элементов в
   * массиве.
   */
  constexpr size_type size() const noexcept { return size_; }

  /**
   * @brief Получение максимального размера массива.
   *
   * @return Максимальный размер массива.
   *
   * Метод `max_size` возвращает максимально возможное количество элементов в
   * массиве. В случае класса `array`, размер которого определяется на этапе
   * компиляции, максимальный размер будет равен размеру массива.
   */
  constexpr size_type max_size() const noexcept { return size(); }

 public:
  /**
   * @brief Обмен содержимым двух массивов.
   *
   * @param other Другой массив для обмена.
   *
   * Метод `swap` меняет местами содержимое текущего массива и другого массива.
   * Это позволяет эффективно обменивать данные между двумя массивами без
   * необходимости копирования.
   */
  constexpr void swap(array &other) noexcept {
    for (auto first1 = begin(), last1 = end(), first2 = other.begin();
         first1 != last1; ++first1, ++first2) {
      T tmp = std::move(*first1);
      *first1 = std::move(*first2);
      *first2 = std::move(tmp);
    }
  }

  /**
   * @brief Заполнение массива одним значением.
   *
   * @param value Значение для заполнения.
   *
   * Метод `fill` заполняет все элементы массива указанным значением.
   * Это позволяет быстро инициализировать массив одним значением.
   */
  void fill(const_reference value) {
    for (auto *itBegin = begin(), *itEnd = end(); itBegin != itEnd; ++itBegin)
      *itBegin = value;
  }

 private:
  value_type data_[N] = {};
  size_type size_ = N;
};

}  // namespace s21

#endif