#ifndef S21_CONTAINERS_SRC_S21_CONTAINERS_AVLTREE_S21_AVLTREE_H
#define S21_CONTAINERS_SRC_S21_CONTAINERS_AVLTREE_S21_AVLTREE_H

#include <functional>
#include <limits>
#include <vector>

namespace s21 {
enum RedBlackTreeColor { pBlack, pRed };

template <typename Key, typename Comparator = std::less<Key>>
class RedBlackTree {
 private:
  struct RedBlackTreeNode;
  struct RedBlackTreeIterator;
  struct RedBlackTreeIteratorConst;

 public:
  using key_type = Key;
  using reference = key_type &;
  using const_reference = const key_type &;
  using iterator = RedBlackTreeIterator;
  using const_iterator = RedBlackTreeIteratorConst;
  using size_type = std::size_t;

  using tree_type = RedBlackTree;
  using tree_node = RedBlackTreeNode;
  using tree_color = RedBlackTreeColor;

  /**
   * @brief Конструктор по умолчанию для класса RedBlackTree.
   *
   * Создает пустое дерево с начальным размером 0.
   */
  RedBlackTree() : head_(new tree_node), size_(0U) {}

  /**
   * @brief Конструктор копирования для класса RedBlackTree.
   *
   * @param other Ссылка на объект RedBlackTree, который нужно скопировать.
   *
   * Создает новое дерево и копирует в него элементы из заданного дерева.
   */
  RedBlackTree(const tree_type &other) : RedBlackTree() {
    if (other.Size() > 0) {
      CopyTreeFromOther(other);
    }
  }

  /**
   * @brief Конструктор перемещения для класса RedBlackTree.
   *
   * @param other Ссылка на объект RedBlackTree, который нужно переместить.
   *
   * Создает новое дерево и перемещает в него элементы из заданного дерева.
   */
  RedBlackTree(tree_type &&other) noexcept : RedBlackTree() { Swap(other); }

  /**
   * @brief Оператор присваивания копирования для класса RedBlackTree.
   *
   * @param other Ссылка на объект RedBlackTree, который нужно скопировать.
   * @return Ссылку на текущий объект RedBlackTree.
   *
   * Присваивает содержимое заданного дерева текущему объекту.
   */
  tree_type &operator=(const tree_type &other) {
    if (this != &other) {
      if (other.Size() > 0) {
        CopyTreeFromOther(other);
      } else {
        Clear();
      }
    }

    return *this;
  }

  /**
   * @brief Оператор присваивания перемещения для класса RedBlackTree.
   *
   * @param other Ссылка на объект RedBlackTree, который нужно переместить.
   * @return Ссылку на текущий объект RedBlackTree.
   *
   * Перемещает содержимое заданного дерева в текущий объект, очищая предыдущее
   * содержимое.
   * @note Метод не выбрасывает исключения.
   */
  tree_type &operator=(tree_type &&other) noexcept {
    Clear();
    Swap(other);
    return *this;
  }

  /**
   * @brief Деструктор для класса RedBlackTree.
   *
   * Освобождает ресурсы, занимаемые объектом RedBlackTree, включая удаление
   * всех узлов дерева.
   */
  ~RedBlackTree() {
    Clear();
    delete head_;
    head_ = nullptr;
  }

  /**
   * @brief Очищает дерево, удаляя все его узлы.
   *
   * @note Метод не выбрасывает исключения.
   */
  void Clear() noexcept {
    Destroy(Root());
    InitializeHead();
    size_ = 0;
  }

  /**
   * @brief Возвращает размер дерева.
   *
   * @return Количество узлов в дереве.
   *
   * @note Метод не выбрасывает исключения.
   */
  size_type Size() const noexcept { return size_; }

  /**
   * @brief Проверяет, пуст ли дерево.
   *
   * @return true, если дерево пуст, и false в противном случае.
   *
   * @note Метод не выбрасывает исключения.
   */
  bool Empty() const noexcept { return size_ == 0; }

  /**
   * @brief Возвращает максимально возможный размер дерева.
   *
   * @return Максимально возможный размер дерева.
   *
   * @note Метод не выбрасывает исключения.
   */
  size_type MaxSize() const noexcept {
    return std::numeric_limits<size_type>::max();
  }

  /**
   * @brief Возвращает итератор, указывающий на первый элемент дерева.
   *
   * @return Итератор, указывающий на первый элемент дерева.
   *
   * @note Метод не выбрасывает исключения.
   */
  iterator Begin() noexcept { return iterator(MostLeft()); }

  /**
   * @brief Возвращает константный итератор, указывающий на первый элемент
   * дерева.
   *
   * @return Константный итератор, указывающий на первый элемент дерева.
   *
   * @note Метод не выбрасывает исключения.
   */
  const_iterator Begin() const noexcept { return const_iterator(MostLeft()); }

  /**
   * @brief Возвращает итератор, указывающий за последний элемент дерева.
   *
   * @return Итератор, указывающий за последний элемент дерева.
   *
   * @note Метод не выбрасывает исключения.
   */
  iterator End() noexcept { return iterator(head_); }

  /**
   * @brief Возвращает константный итератор, указывающий за последний элемент
   * дерева.
   *
   * @return Константный итератор, указывающий за последний элемент дерева.
   *
   * @note Метод не выбрасывает исключения.
   */
  const_iterator End() const noexcept { return const_iterator(head_); }

  /**
   * @brief Объединяет два дерева, перемещая все узлы из одного дерева в другое.
   *
   * @param other Ссылка на другое дерево, с которым нужно объединить текущее
   * дерево.
   *
   * @note Метод изменяет состояние текущего дерева, добавляя в него узлы из
   * другого дерева. После объединения другое дерево инициализируется в
   * начальное состояние.
   */
  void Merge(tree_type &other) {
    // не работает, не ебу
    if (this != &other) {
      iterator other_begin = other.Begin();

      // Пока элементы есть в other, извлекаем их
      while (other.size_ > 0) {
        tree_node *moving_node = other_begin.node_;
        ++other_begin;

        // Отцепляем узел от других узлов в other

        if (moving_node->left_ != nullptr) {
          moving_node->left_->parent_ = moving_node->parent_;
        }

        if (moving_node->right_ != nullptr) {
          moving_node->right_->parent_ = moving_node->parent_;
        }

        if (moving_node->parent_->left_ == moving_node) {
          moving_node->parent_->left_ = nullptr;
        }

        if (moving_node->parent_->right_ == moving_node) {
          moving_node->parent_->right_ = nullptr;
        }

        // Приводим узел к виду по умолчанию
        moving_node->ToDefault();

        --other.size_;

        Insert(Root(), moving_node, false);
      }

      // Приводим head дерева other в корректное состояние для пустого
      // контейнера, чтобы other остался консистентным.
      other.InitializeHead();
    }
  }

  /**
   * @brief Объединяет два дерева, перемещая узлы из одного дерева в другое,
   * если ключи этих узлов уникальны.
   *
   * @param other Ссылка на другое дерево, с которым нужно объединить текущее
   * дерево.
   *
   * @note Метод изменяет состояние текущего дерева, добавляя в него узлы из
   * другого дерева, если их ключи уникальны. После объединения другое дерево
   * остается неизменным.
   */
  void MergeUnique(tree_type &other) {
    if (this != &other) {
      iterator other_begin = other.Begin();
      iterator other_end = other.End();

      while (other_begin != other_end) {
        iterator result_it = Find(other_begin.node_->key_);
        if (result_it == End()) {
          iterator tmp = other_begin;
          ++other_begin;
          tree_node *moving_node = other.ExtractNode(tmp);
          Insert(Root(), moving_node, false);
        } else
          ++other_begin;
      }
    }
  }

  /**
   * @brief Вставляет новый узел в дерево с заданным ключом.
   *
   * @param key Ключ, который будет присвоен новому узлу.
   * @return Итератор, указывающий на вставленный узел.
   *
   * @note Метод создает новый узел с заданным ключом и вставляет его в дерево,
   *       используя вспомогательный метод Insert с корнем дерева.
   *       Вставленный узел всегда имеет красный цвет, что соответствует
   * свойствам красно-черного дерева.
   */
  iterator Insert(const key_type &key) {
    tree_node *new_node = new tree_node{key};
    return Insert(Root(), new_node, false).first;
  }

  /**
   * @brief Вставляет элемент со значением key в контейнер, если контейнер еще
   * не содержит элемент с эквивалентным ключом.
   *
   * @param key Значение элемента для вставки
   * @return std::pair<iterator, bool> - Пара, состоящая из итератора для
   * вставленного элемента (или для элемента, который предотвратил вставку) и
   * логического значения, установленного в true, если вставка произошла
   * (false, если вставка не произошла
   */
  std::pair<iterator, bool> InsertUnique(const key_type &key) {
    tree_node *new_node = new tree_node{key};
    std::pair<iterator, bool> result = Insert(Root(), new_node, true);
    if (result.second == false)
      // Если вставка не произошла, то удаляем созданный узел
      delete new_node;

    return result;
  }

  /**
   * @brief Размещает новые элементы args в контейнер. Если в контейнере
   * есть элементы с эквивалентным ключом, вставка выполняется по верхней
   * границе этого диапазона.
   *
   * @tparam Args Пакет параметров шаблона (Parameter pack)
   * @param args Уже созданные элементы, которые необходимо вставить в
   * соответствующий контейнер.
   * @details Модифицированная версия метода emplace, которая отличается от
   * реализации в std, т.к. получает в качестве аргументов args уже созданные
   * объекты для размещения в контейнере (а не параметры для конструирования
   * объектов)
   *
   * Однако при реализации мы должны сохранить основную идею Emplace:
   * Основное отличие от insert - избежать ненужных копирований объекта,
   * единожды созданный временный объект будет передаваться по функциям без
   * копирования и встроится в дерево.
   *
   * @return std::vector<std::pair<iterator, bool>> Т.к. функция может
   * вставить несколько элементов, то возвращается вектор, содержащий пары
   * результата вставки для каждого вставляемого элемента. Формат пары
   * идентичен методу InsertUnique()
   */
  template <typename... Args>
  std::vector<std::pair<iterator, bool>> insert_many(Args &&...args) {
    std::vector<std::pair<iterator, bool>> result;
    // Т.к. args может быть большим, но это число нам сразу известно, то
    // выделяем нужное количество памяти на вектор, чтобы избежать ненужных
    // повторных выделений памяти в процессе
    result.reserve(sizeof...(args));

    for (auto item : {std::forward<Args>(args)...}) {
      tree_node *new_node = new tree_node(std::move(item));
      std::pair<iterator, bool> result_insert = Insert(Root(), new_node, false);
      result.push_back(result_insert);
    }

    return result;
  }

  /**
   * @brief Размещает новые элементы args в контейнер, если контейнер ещё не
   * содержит элемент с эквивалентным ключом.
   *
   * @details В остальном работает идентично insert_many().
   *
   * @tparam Args Пакет параметров шаблона (Parameter pack)
   * @param args Уже созданные элементы, которые необходимо вставить в
   * соответствующий контейнер.
   * @return std::vector<std::pair<iterator, bool>> Т.к. функция может
   * вставить несколько элементов, то возвращается вектор, содержащий пары
   * результата вставки для каждого вставляемого элемента. Формат пары
   * идентичен методу InsertUnique()
   */
  template <typename... Args>
  std::vector<std::pair<iterator, bool>> insert_many_unique(Args &&...args) {
    std::vector<std::pair<iterator, bool>> result;
    result.reserve(sizeof...(args));

    for (auto item : {std::forward<Args>(args)...}) {
      tree_node *new_node = new tree_node(std::move(item));
      std::pair<iterator, bool> result_insert = Insert(Root(), new_node, true);
      if (result_insert.second == false) delete new_node;
      result.push_back(result_insert);
    }

    return result;
  }

  /**
   * @brief Находит элемент с ключом, эквивалентным key. Стандарт не
   * регулирует, какой именно элемент будет найден, если их несколько, но в
   * gcc находится элемент из lower_bound(), поэтому делаем аналогично
   *
   * @param key Искомый ключ
   * @return iterator Итератор найденного элемента. Если такой элемент не
   * найден, возвращается end().
   */
  iterator Find(const_reference key) {
    iterator result = LowerBound(key);

    if (result == End() || cmp_(key, *result))
      // Если LowerBound() ничего не нашел или нашел элемент > key
      return End();

    return result;
  }

  /**
   * @brief Находит итератор к первому элементу, который не меньше заданного
   * ключа.
   *
   * @param key Ключ, относительно которого выполняется поиск.
   * @return Итератор к первому элементу, который не меньше заданного ключа.
   * Если такого элемента нет, возвращает итератор к концу контейнера.
   *
   * @details Метод реализует алгоритм поиска в двоичном дереве поиска, начиная
   * с корня. В процессе поиска, если текущий узел не меньше искомого ключа, он
   * сохраняется как предварительный результат, и поиск продолжается в левом
   * поддереве, так как в нем могут находиться элементы, меньше текущего узла,
   * но больше искомого ключа. Если текущий узел меньше искомого ключа, поиск
   * продолжается в правом поддереве. Если в процессе поиска достигнут узел с
   * ключом, меньшим искомого, этот узел становится конечным результатом.
   *
   * @note Если в дереве нет элементов, больше или равных заданному ключу, метод
   * возвращает итератор к концу контейнера.
   */
  iterator LowerBound(const_reference key) {
    tree_node *start = Root();
    tree_node *result = End().node_;

    while (start != nullptr) {
      if (!cmp_(start->key_, key)) {
        // Если найден элемент не меньше key, то запоминаем его как
        // предварительный результат поисков (т.е. как минимум один
        // элемент уже найден), далее в цикле будем обновлять этот
        // указатель, если ниже по дереву найдем еще один элемент не
        // меньше key
        result = start;
        // Сдвигаем указатель на левый узел найденного узла, т.к. слева
        // располагаются элементы меньше текущего и они могут быть ближе
        // к искомому значению
        start = start->left_;
      } else {
        // Если текущий узел меньше искомого, то идем вправо, т.к. там
        // находятся элементы больше текущего
        start = start->right_;
      }
    }

    return iterator(result);
  }

  /**
   * @brief Возвращает итератор, указывающий на первый элемент, который больше
   * key.
   *
   * @details Алгоритм в целом аналогичен LowerBound, но типа наоборот (см.
   * отличия в комментариях по ходу функции).
   *
   * @param key ключевое значение, с которым сравниваются элементы
   * @return iterator Итератор, указывающий на первый элемент, который больше
   * key. Если такой элемент не найден, возвращается итератор End().
   */
  iterator UpperBound(const_reference key) {
    tree_node *start = Root();
    tree_node *result = End().node_;

    while (start != nullptr) {
      if (cmp_(key, start->key_)) {
        // Если искомое значение меньше значения узла, то запоминаем
        // текущий узел, т.к. он больше искомого
        result = start;
        // Продолжаем поиски в левой ветви, т.к. там могут быть значения
        // меньше текущего узла, а нам надо найти самый маленький (т.е.
        // ближайший к key) узел
        start = start->left_;
      } else {
        // В противном случае ищем узлы в правой ветви
        start = start->right_;
      }
    }

    return iterator(result);
  }

  /**
   * @brief Удаляет узел из дерева по итератору.
   *
   * @param pos Итератор, указывающий на удаляемый узел.
   *
   * @details Метод удаляет узел из двоичного дерева поиска, используя итератор
   * для указания на удаляемый узел. Сначала вызывается метод ExtractNode,
   * который извлекает узел из дерева, сохраняя его структуру. Затем удаляемый
   * узел освобождается с помощью оператора delete.
   *
   * @note Этот метод предназначен для использования в контексте классов,
   * реализующих двоичные деревья поиска, где итераторы используются для доступа
   * к узлам дерева.
   */
  void Erase(iterator pos) noexcept {
    tree_node *result = ExtractNode(pos);
    delete result;
  }

  /**
   * @brief Меняет местами содержимое текущего дерева с другим деревом.
   *
   * @param other Другое дерево, с которым происходит обмен.
   *
   * @details Метод обменивает содержимое текущего дерева с другим деревом,
   * используя стандартную функцию `std::swap` для обмена значений указателей на
   * корневые узлы, размеров деревьев и сравнивающих функций. Это позволяет
   * эффективно обменять данные между двумя деревьями без необходимости
   * копирования или создания новых узлов.
   *
   * @note После выполнения этого метода, оба дерева будут содержать данные друг
   * друга, а их оригинальные данные будут утеряны. Этот метод предназначен для
   * использования в ситуациях, когда необходимо быстро обменять данные между
   * двумя деревьями, например, в алгоритмах, требующих временного обмена
   * состояниями деревьев.
   */
  void Swap(tree_type &other) noexcept {
    std::swap(head_, other.head_);
    std::swap(size_, other.size_);
    std::swap(cmp_, other.cmp_);
  }

  /**
   * @brief Проверяет корректность структуры и свойств красно-черного дерева.
   *
   * @return true, если дерево корректно, иначе false.
   *
   * @details Метод проверяет несколько ключевых свойств красно-черного дерева,
   * чтобы убедиться в его корректности:
   * - Корень дерева должен быть черным.
   * - Все листья (узлы без детей) должны быть черными.
   * - Каждый красный узел должен иметь черных детей.
   * - Любой простой путь от корня до листового узла содержит одинаковое число
   * черных узлов.
   *
   * @note Этот метод используется для диагностики и проверки корректности
   * работы алгоритмов, работающих с красно-черными деревьями, и может быть
   * полезен в отладке.
   */
  bool CheckTree() const noexcept {
    // head дерева должен быть красный.
    if (head_->color_ == pBlack) return false;

    // Пустое дерево корректно всегда
    if (Root() == nullptr) return true;

    // Корень дерева должен быть чёрный.
    if (Root()->color_ == pRed) return false;

    // Оба потомка каждого красного узла — чёрные.
    if (CheckRedNodes(Root()) == false) return false;

    // Любой простой путь от узла-предка до листового узла-потомка содержит
    // одинаковое число чёрных узлов.
    if (ComputeBlackHeight(Root()) == -1) return false;

    // Если всё ок, то возвращаем true
    return true;
  }
  tree_node *&GetRoot() { return head_->parent_; }

 private:
  /**
   * @brief Копирует дерево из другого дерева, заменяя текущее дерево на копию.
   *
   * @param other Ссылка на другое дерево, из которого будет произведена копия.
   *
   * @note Метод создает глубокую копию дерева, включая все узлы и их свойства.
   *       После копирования, текущее дерево полностью заменяется на копию,
   *       а размер и сравнивающая функция также копируются из другого дерева.
   */
  void CopyTreeFromOther(const tree_type &other) {
    tree_node *other_copy_root = CopyTree(other.Root(), nullptr);
    Clear();
    Root() = other_copy_root;
    Root()->parent_ = head_;
    MostLeft() = SearchMinimum(Root());
    MostRight() = SearchMaximum(Root());
    size_ = other.size_;
    cmp_ = other.cmp_;
  }

  /**
   * @brief Рекурсивно копирует поддерево, начиная с заданного узла.
   *
   * @param node Указатель на узел, с которого начинается копирование.
   * @param parent Указатель на родительский узел в скопированном дереве.
   * @return Указатель на корневой узел скопированного поддерева.
   *
   * @note Метод создает глубокую копию поддерева, включая все узлы и их
   * свойства. В случае возникновения исключения во время копирования, метод
   * удаляет уже скопированные узлы и перебрасывает исключение.
   */
  [[nodiscard]] tree_node *CopyTree(const tree_node *node, tree_node *parent) {
    // Если вылетит исключение при создании самого первого узла, то ничего
    // страшного, ничего создано не будет
    tree_node *copy = new tree_node{node->key_, node->color_};
    // А вот все рекурсивные вызовы оборачиваем в try/catch, чтобы в случае
    // возникновения исключения удалить все уже скопированные узлы (иначе
    // будет утечка)
    try {
      if (node->left_) {
        copy->left_ = CopyTree(node->left_, copy);
      }

      if (node->right_) {
        copy->right_ = CopyTree(node->right_, copy);
      }
    } catch (...) {
      Destroy(copy);
      throw;
    }

    copy->parent_ = parent;
    return copy;
  }

  /**
   * @brief Рекурсивно удаляет поддерево, начиная с заданного узла, и
   * освобождает память, занимаемую узлами.
   *
   * @param node Указатель на узел, с которого начинается удаление.
   *
   * @note Метод предназначен для освобождения памяти, занимаемой узлами дерева.
   *       Рекурсивно удаляет левое и правое поддеревья узла, а затем удаляет
   * сам узел. Если узел равен nullptr, метод не выполняет никаких действий.
   */
  void Destroy(tree_node *node) noexcept {
    if (node == nullptr) return;
    Destroy(node->left_);
    Destroy(node->right_);
    delete node;
  }

  /**
   * @brief Инициализирует голову дерева, устанавливая корневой узел, самый
   * левый и самый правый узлы в начальное состояние.
   *
   * @note Метод предназначен для инициализации дерева, устанавливая корневой
   * узел в nullptr, а самый левый и самый правый узлы в голову дерева.
   */
  void InitializeHead() noexcept {
    Root() = nullptr;
    MostLeft() = head_;
    MostRight() = head_;
  }

  /**
   * @brief Возвращает ссылку на корневой узел дерева.
   *
   * @return Ссылка на корневой узел дерева.
   *
   * @note Метод предназначен для доступа к корневому узлу дерева.
   */
  tree_node *&Root() { return head_->parent_; }

  /**
   * @brief Возвращает константную ссылку на корневой узел дерева.
   *
   * @return Константная ссылка на корневой узел дерева.
   *
   * @note Метод предназначен для доступа к корневому узлу дерева в контексте
   * const методов.
   */
  const tree_node *Root() const { return head_->parent_; }

  /**
   * @brief Возвращает ссылку на самый левый узел дерева.
   *
   * @return Ссылка на самый левый узел дерева.
   *
   * @note Метод предназначен для доступа к самому левому узлу дерева.
   */
  tree_node *&MostLeft() { return head_->left_; }

  /**
   * @brief Возвращает константную ссылку на самый левый узел дерева.
   *
   * @return Константная ссылка на самый левый узел дерева.
   *
   * @note Метод предназначен для доступа к самому левому узлу дерева в
   * контексте const методов.
   */
  const tree_node *MostLeft() const { return head_->left_; }

  /**
   * @brief Возвращает ссылку на самый правый узел дерева.
   *
   * @return Ссылка на самый правый узел дерева.
   *
   * @note Метод предназначен для доступа к самому правому узлу дерева.
   */
  tree_node *&MostRight() { return head_->right_; }

  /**
   * @brief Вставляет новый узел в дерево, начиная с заданного корня.
   *
   * @param root Указатель на корневой узел, с которого начинается поиск места
   * для вставки.
   * @param new_node Указатель на новый узел, который нужно вставить.
   * @param unique_only Флаг, указывающий, разрешена ли вставка неуникальных
   * элементов.
   * @return Пара, содержащая итератор на вставленный узел и флаг, указывающий
   * на успешность вставки.
   *
   * @note Метод реализует вставку нового узла в дерево, учитывая условия
   * уникальности ключей и балансировку дерева. В случае успешной вставки,
   * возвращает итератор на вставленный узел и true. Если вставка неуникального
   * элемента не разрешена и элемент с таким ключом уже существует, возвращает
   * итератор на существующий узел и false.
   */
  std::pair<iterator, bool> Insert(tree_node *root, tree_node *new_node,
                                   bool unique_only) {
    tree_node *node = root;
    tree_node *parent = nullptr;

    // Ищем место для вставки, пока не дойдем до пустого узла
    while (node != nullptr) {
      parent = node;
      if (cmp_(new_node->key_, node->key_)) {
        // Если new_node < node
        node = node->left_;
      } else {
        if (unique_only == false) {
          // Если вставка неуникальных элементов разрешена, то всегда
          // продолжаем искать дальше в правой ветви (т.к. нам не
          // важно, равно ли значение текущего узла вставляемому)
          node = node->right_;
        } else {
          // Если вставка неуникальных элементов не разрешена, то
          // выясняем node > new_node или node == new_node
          if (cmp_(node->key_, new_node->key_)) {
            // Если node > new_node, то продолжаем поиски в правой
            // ветви
            node = node->right_;
          } else {
            // Если node == new_node то возвращаем результат о
            // невозможности вставки элемента
            return {iterator(node), false};
          }
        }
      }
    }

    // После окончания цикла parent буден указывать на узел, потомком
    // которого станет new_node. При этом parent может быть равен nullptr,
    // если в дереве не окажется узлов (пустое дерево), если мы даже не
    // зашли в цикл выше
    if (parent != nullptr) {
      new_node->parent_ = parent;
      if (cmp_(new_node->key_, parent->key_)) {
        parent->left_ = new_node;
      } else
        parent->right_ = new_node;
    } else {
      // Если дерево пустое, то new_node становится корнем дерева
      new_node->color_ = pBlack;
      new_node->parent_ = head_;
      Root() = new_node;
    }

    ++size_;

    // Обновляем указатель на самый маленький элемент дерева, если
    // необходимо
    if (MostLeft() == head_ || MostLeft()->left_ != nullptr)
      MostLeft() = new_node;

    // Обновляем указатель на самый большой элемент дерева, если необходимо
    if (MostRight() == head_ || MostRight()->right_ != nullptr)
      MostRight() = new_node;

    // Вызываем балансировку после вставки нового узла
    BalancingInsert(new_node);

    return {iterator(new_node), true};
  }

  /**
   * @brief Балансировка дерева, после вставки нового элемента.
   * @details Основной алгоритм расписан по ходу функции, используемая
   * терминология:
   * node — добавленный элемент (сын), который нарушает 3 пункт правил (Оба
   * потомка каждого красного узла — чёрные). Хотя на самом деле может и не
   * нарушает, мы всегда вызываем балансировку. Но если условия не нарушены,
   * то мы не зайдем в цикл while
   *
   * parent — папа элемента node
   *
   * gparent — дедушка элемента node, папа элемента parent
   *
   * uncle — дядя элемента node, брат элемента parent, второй сын элемента
   * gparent
   *
   * При перебалансировке возможны 6 различных случаев:
   * 1) 3 случая, когда дядя справа у деда
   * 2) 3 случая, когда дядя слева у деда
   *
   * Походу функции подробно описаны первые 3 случая. Вторые 3 случая
   * зеркально отражают первые 3 случая (это очень наглядно будет видно по
   * коду).
   *
   * @param node добавленный элемент
   */
  void BalancingInsert(tree_node *node) {
    // Отец
    tree_node *parent = node->parent_;
    int flag = 1;

    while (node != Root() && parent->color_ == pRed && flag) {
      // Дед
      tree_node *gparent = parent->parent_;

      if (gparent->left_ == parent) {
        // Обрабатываем ситуацию, когда дядя справа у деда
        tree_node *uncle = gparent->right_;

        if (uncle != nullptr && uncle->color_ == pRed) {
          // Случай первый — красный дядя

          // Если и отец, и дядя красного цвета, то мы можем
          // «спустить» чёрный цвет с уровня деда на уровень отца и
          // перекрасить узлы. В этом случае «чёрная высота» останется
          // прежней, однако возможно нарушение 3 правила для элемента
          // gparent, поэтому необходимо рекурсивно вызвать дальнейшую
          // балансировку для этого узла (следующая итерация цикла
          // while).
          parent->color_ = pBlack;
          uncle->color_ = pBlack;
          gparent->color_ = pRed;
          node = gparent;
          parent = node->parent_;
        } else {
          // Случай второй — чёрный дядя — папа и дед в разных
          // сторонах.

          // Эту структуру необходимо привести к третьему случаю,
          // когда папа и дед идут в одну сторону. Для этого нужно
          // выполнить малый поворот от сына node к его отцу и далее
          // будет вызван 3 случай для элемента node.
          if (parent->right_ == node) {
            RotateLeft(parent);
            std::swap(parent, node);
          }
          // Случай третий — чёрный дядя — папа и дед в одной стороне

          // В этом случае мы уже можем совершить большой поворот от
          // отца через деда к чёрному дяде и перекрасить parent в
          // чёрный, а gparent в красный.
          RotateRight(gparent);
          gparent->color_ = pRed;
          parent->color_ = pBlack;
          flag = 0;
        }
      } else {
        // Обрабатываем ситуацию, когда дядя слева у деда
        tree_node *uncle = gparent->left_;

        if (uncle != nullptr && uncle->color_ == pRed) {
          // Случай первый — красный дядя
          // Аналогично ситуации, когда дядя справа у деда
          parent->color_ = pBlack;
          uncle->color_ = pBlack;
          gparent->color_ = pRed;

          node = gparent;
          parent = node->parent_;
        } else {
          // Случай второй — чёрный дядя — папа и дед в разных
          // сторонах. Аналогично ситуации, когда дядя справа у деда
          if (parent->left_ == node) {
            RotateRight(parent);
            std::swap(parent, node);
          }

          // Случай третий — чёрный дядя — папа и дед в одной стороне
          // Аналогично ситуации, когда дядя справа у деда
          RotateLeft(gparent);
          gparent->color_ = pRed;
          parent->color_ = pBlack;
          flag = 0;
        }
      }
    }

    Root()->color_ = pBlack;
  }

  /**
   * @brief Выполняет правую вращение вокруг заданного узла.
   *
   * @param node Указатель на узел, вокруг которого выполняется вращение.
   *
   * @note Метод предназначен для балансировки красно-черного дерева.
   *       Вращение изменяет структуру дерева, перемещая узел и его левого
   * потомка, сохраняя при этом свойства красно-черного дерева. Вращение может
   * быть использовано как часть операций вставки или удаления узлов.
   */
  void RotateRight(tree_node *node) noexcept {
    tree_node *const pivot = node->left_;
    pivot->parent_ = node->parent_;

    if (node == Root()) {
      Root() = pivot;
    } else if (node->parent_->left_ == node) {
      node->parent_->left_ = pivot;
    } else {
      node->parent_->right_ = pivot;
    }

    node->left_ = pivot->right_;
    if (pivot->right_ != nullptr) pivot->right_->parent_ = node;

    node->parent_ = pivot;
    pivot->right_ = node;
  }

  /**
   * @brief Выполняет левую вращение вокруг заданного узла.
   *
   * @param node Указатель на узел, вокруг которого выполняется вращение.
   *
   * @note Метод предназначен для балансировки красно-черного дерева.
   *       Вращение изменяет структуру дерева, перемещая узел и его правого
   * потомка, сохраняя при этом свойства красно-черного дерева. Вращение может
   * быть использовано как часть операций вставки или удаления узлов.
   */
  void RotateLeft(tree_node *node) noexcept {
    tree_node *const pivot = node->right_;

    pivot->parent_ = node->parent_;

    if (node == Root())
      Root() = pivot;
    else if (node->parent_->left_ == node)
      node->parent_->left_ = pivot;
    else
      node->parent_->right_ = pivot;

    node->right_ = pivot->left_;
    if (pivot->left_ != nullptr) pivot->left_->parent_ = node;

    node->parent_ = pivot;
    pivot->left_ = node;
  }

  /**
   * @brief Изымает узел в позиции pos из дерева, при необходимости
   * осуществляется ребалансировка дерева.
   *
   * @details Чтобы удалить узел из красно-черного дерева, мы следуем обычному
   * процессу удаления BST, который гарантирует, что удаляемый узел является
   * либо конечным узлом (т.е. не содержит дочерних узлов), либо имеет только
   * один дочерний узел. Возможные варианты удаляемых узлов:
   *
   * 1) К2 — красный узел с двумя детьми.
   * Задача удаления узла с двумя дочерними элементами сводится к задаче
   * удаления узла с одним или нулём дочерних элементов. Для этого необходимо
   * найти ближайший элемент, который меньше или больше удаляемого и поменять
   * их местами.
   *
   * ВАЖНО: Наиболее удобно при обмене элементов местами изменять только
   * значения в узлах, а цвет оставлять прежним, чтобы не нарушать структуру
   * дерева и не изменять чёрную высоту. Обычно это быстро, т.к. происходит
   * обмен только одного поля (значения), даже для сложных классов (если класс
   * поддерживает move). И это проще реализовать, т.к. не надо делать
   * фактический обмен узлов с перепривязкой всех указателей на узлы. Однако в
   * этом случае мы фактический удаляем другой узел, хоть и содержащую нужное
   * значение. Соответственно в этом случае мы не можем гарантировать, что
   * указатели/итераторы на другие узлы дерева останутся валидными. Т.к.
   * оригинальная реализация дерева в STL требует от нас сохранять указатели и
   * итераторы валидными (References and iterators to the erased elements are
   * invalidated. Other references and iterators are not affected.), то мы
   * будем наоборот обменивать узлы целиком, оставляя значение на старом
   * месте.
   *
   * После обмена нужно удалить узел из его нового места. Это будет либо
   * самый правый элемент в левой ветке (максимальный слева), либо самый левый
   * в правой (минимальный справа) (см ниже пояснение с *), в любом случае у
   * него не будет одного дочернего узла слева или справа.
   *
   * Таким образом, задача удаления узла с 2 детьми сводится к задаче удаления
   * элемента с 1 или 0 детьми.
   *
   * *) При поиске ближайшего элемента в идеале необходимо просматривать и
   * левое и правое поддеревья, чтобы выбрать ближайшее значение к удаляемому.
   * Но мы будем всегда искать справа (если правое поддерево есть, конечно),
   * т.к. это проще и не оказывает существенного влияния на работу дерева.
   *
   * 2) Ч2 — чёрный узел с двумя детьми.
   * Аналогично предыдущему случаю К2, задача удаления узла с 2 детьми
   * сводится к задаче удаления элемента с 1 или 0 детьми.
   *
   * 3) К1 — красный узел с одним ребёнком.
   * Если у красного узла одного ребёнка нет, значит, вместо него находится
   * чёрный NIL-элемент и чёрная высота красного узла равна 1. Следовательно,
   * с другой стороны чёрная высота также должны быть равна 1. Но так как у
   * красного узла дочерний элемент не может быть красного цвета, то другой
   * его ребёнок должен быть чёрного цвета. Так как чёрная высота должна быть
   * равна 1, то это может быть только чёрный NIL-элемент, так как в случае
   * обычного чёрного элемента высота будет выше.
   *
   * Таким образом, К1 случай не имеет места быть.
   *
   * 4) Ч1 — чёрный узел с одним ребёнком.
   * Если у чёрного элемента нет одного ребёнка, значит, вместо него находится
   * чёрный NIL-элемент с чёрной высотой 1. Следовательно, с другой стороны
   * должен быть красный узел без детей. Для удаления такого элемента обменять
   * значения красного и чёрного узлов и удалить красный узел (аналогично
   * случаю К2 вместо обмена значений мы будем делать обмен узлов), чёрная
   * высота при этом сохранится.
   *
   * Таким образом, К1 сводится к задаче удаления красного узла без детей (К0)
   *
   * 5) К0 — красный узел без детей.
   * Просто удаляем элемент, чёрная высота при этом сохранится.
   *
   * 6) Ч0 — чёрный узел без детей. Просто удаляем узел, но при этом чёрная
   * высота изменится. Соответственно необходимо запустить перебалансировку.
   *
   * @param pos Итератор, указывающий на извлекаемый узел.
   * @return tree_node* Извлеченный узел дерева.
   */
  tree_node *ExtractNode(iterator pos) noexcept {
    if (pos == End()) {
      // Запрещаем удалять служебный узел (head_), чтобы сохранить
      // консистентность нашего класса.
      return nullptr;
    }

    tree_node *deleted_node = pos.node_;

    // Обработка К2 и Ч2
    if (deleted_node->left_ != nullptr && deleted_node->right_ != nullptr) {
      // Находим самый левый узел в правой ветке (минимальный справа)
      tree_node *replace = SearchMinimum(deleted_node->right_);
      // Обмениваем местами удаляемый узел и найденный узел
      SwapNodesForErase(deleted_node, replace);
    }

    // Обработка К1 — не требуется, т.к. такой случай невозможен

    // Обработка Ч1
    if (deleted_node->color_ == pBlack &&
        ((deleted_node->left_ == nullptr && deleted_node->right_ != nullptr) ||
         (deleted_node->left_ != nullptr && deleted_node->right_ == nullptr))) {
      // Находим красный узел без детей (К0) для обмена значений с ним
      tree_node *replace;
      if (deleted_node->left_ != nullptr)
        replace = deleted_node->left_;
      else
        replace = deleted_node->right_;
      // Обмениваем местами удаляемый узел и найденный узел
      SwapNodesForErase(deleted_node, replace);
    }

    // Обработка К0
    // Дополнительных действий не требуется узел будет просто удален в конце
    // функции. При таком случае все необходимые переменные для удаления уже
    // заполнены корректно

    // Обработка Ч0
    // Самый сложный и интересный случай, нам необходимо перед удалением
    // перебаласировать дерево таким образом, чтобы черная высота не
    // нарушилась после удаления узла
    if (deleted_node->color_ == pBlack && deleted_node->left_ == nullptr &&
        deleted_node->right_ == nullptr)
      EraseBalancing(deleted_node);

    // Теперь собственно изымаем из дерева узел, который мы удаляем.
    if (deleted_node == Root()) {
      // Отдельно обрабатываем случай, когда удаляем корень дерева
      // Удаление именно корня возможно только в том случае, если он
      // единственный элемент дерева (в остальных случаях мы сведем задачу
      // к удалению другого узла). Поэтому в даном случае приводим
      // состояние служебного узла head_ в соответствие с изначальными
      // данными для пустого дерева.
      InitializeHead();
    } else {
      // В остальных случаях отцепляем ссылки родителя на нашу удаляемый
      // узел
      if (deleted_node == deleted_node->parent_->left_)
        deleted_node->parent_->left_ = nullptr;
      else
        deleted_node->parent_->right_ = nullptr;

      // Ищем новый минимум для служебного узла, если мы удаляем старый
      // минимум
      if (MostLeft() == deleted_node) MostLeft() = SearchMinimum(Root());

      // Ищем новый максимум для служебного узла, если мы удаляем старый
      // максимум
      if (MostRight() == deleted_node) MostRight() = SearchMaximum(Root());
    }

    // И уменьшаем количество элементов дерева, т.к. мы изъяли из него один
    // узел
    --size_;

    // Приводим узел к виду по умолчанию
    deleted_node->ToDefault();

    return deleted_node;
  }

  /**
   * @brief Меняет местами узлы node и other с целью последующего удаления
   * узла node - это важный момент, т.е. это не универсальный свап узлов, а
   * только частный случай (универсальный более сложен, но нам не нужны эти
   * лишние действия)
   *
   * Необходимость обмена именно узлов, а не их значений описана в функции
   * ExtractNode()
   **/
  void SwapNodesForErase(tree_node *node, tree_node *other) noexcept {
    if (other->parent_->left_ == other)
      other->parent_->left_ = node;
    else
      other->parent_->right_ = node;

    if (node == Root()) {
      // Если node является корнем дерева, то меняем ссылку на новый
      // корень
      Root() = other;
    } else {
      if (node->parent_->left_ == node)
        node->parent_->left_ = other;
      else
        node->parent_->right_ = other;
    }

    // Свапаем всё, кроме key_, т.к. ключи должны остаться на своем месте в
    // дереве, а все остальное должно обменяться (см. описание алгоритма
    // удаления)
    std::swap(node->parent_, other->parent_);
    std::swap(node->left_, other->left_);
    std::swap(node->right_, other->right_);
    std::swap(node->color_, other->color_);

    if (node->left_) {
      // При текущем алгоритме удаления у нас не может быть left_
      // заполнен, но в универсальном варианте надо проверять
      node->left_->parent_ = node;
    }

    if (node->right_) node->right_->parent_ = node;

    if (other->left_) other->left_->parent_ = other;

    if (other->right_) other->right_->parent_ = other;
  }

  /**
   * @brief Функция для перебалансировки дерева перед удалением узла
   * deleted_node, чтобы черная высота не нарушилась после удаления узла.
   *
   * @details Перебалансировка выполняется в том случае, если удаляется черный
   * узел без детей, т.к. в этом случае гарантированно нарушается свойство 5
   * красно-чёрного дерева (свойства описаны в начале файла).
   *
   * При перебалансировке возможны 8 различных случаев:
   * 1) 4 случая, если удаляемый элемент находится слева от родителя (левый
   * сын).
   * 2) 4 случая, если удаляемый элемент находится справа от родителя
   * (правый сын).
   *
   * Мы рассмотрим только 4 случая для левого сына. Вторые 4 случая (для
   * правого сына) зеркально отражают первые четыре случая (это очень наглядно
   * будет видно по коду).
   *
   * Терминология далее:
   * check_node - элемент, для которого мы хотим восстановить высоту (на
   * первой итерации является удаляемым элементом) parent - Родитель
   * check_node sibling - Брат или сестра check_node (второй ребенок parent)
   *
   * Возможные случаи для для левого сына:
   * 6.1) sibling красного цвета.
   *
   * В этом случае мы меняем местами цвета sibling и parent, а затем выполняем
   * поворот налево через parent (при этом изменятся parent и sibling в
   * текущей итерации алгоритма). Это сводит случай 6.1 к случаям 6.2, 6.3
   * или 6.4.
   *
   * 6.2) sibling черного цвета и оба ребенка sibling черного цвета.
   *
   * В этом случае мы меняем цвет sibling на красный.
   * Если цвет parent красный, то мы меняем его цвет на черный и останавливаем
   * балансировку (дерево будет сбалансировано).
   * Если цвет parent черный, мы устанавливаем check_node равной parent и
   * переходим к следующей итерации балансировки (т.е. начинаем проверять
   * случаи для нового check_node, начиная с 6.1). Это обусловлено тем, что в
   * данном случае мы изменили цвет sibling на красный - в результате чёрная
   * высота всей нашей структуры уменьшилась на 1 и мы должны рекурсивно
   * вызывать балансировку для parent.
   *
   * 6.3) sibling черного цвета, левый ребенок sibling красный, правый ребенок
   * sibling черный.
   *
   * В этом случае мы меняем местами цвета sibling и левого ребенка sibling, а
   * затем выполняем поворот направо через sibling (при этом изменится sibling
   * в текущей итерации алгоритма). Это сводит случай 6.3 к случаю 6.4.
   *
   * 6.4) sibling черного цвета, правый ребенок sibling красный.
   *
   * В этом случае мы меняем цвет правого ребенка sibling на черный, меняем
   * цвет sibling на цвет parent, меняем цвет parent на черный, а затем
   * выполняем поворот налево через sibling. После этого дерево будет
   * сбалансировано, останавливаем балансировку
   *
   * @param deleted_node Удаляемый узел
   */
  void EraseBalancing(tree_node *deleted_node) noexcept {
    tree_node *check_node = deleted_node;
    tree_node *parent = deleted_node->parent_;

    // Проверку осуществляем в цикле, пока проверяемый узел черный
    // (необходимость зацикливания указана в описании случая 6.2)). Ну или
    // пока дерево не кончится
    while (check_node != Root() && check_node->color_ == pBlack) {
      if (check_node == parent->left_) {
        // Удаляемый элемент находится слева от родителя
        tree_node *sibling = parent->right_;

        // Случай 6.1
        if (sibling->color_ == pRed) {
          std::swap(sibling->color_, parent->color_);
          RotateLeft(parent);
          parent = check_node->parent_;
          sibling = parent->right_;
        }

        // Случай 6.2
        if (sibling->color_ == pBlack &&
            (sibling->left_ == nullptr || sibling->left_->color_ == pBlack) &&
            (sibling->right_ == nullptr || sibling->right_->color_ == pBlack)) {
          sibling->color_ = pRed;
          if (parent->color_ == pRed) {
            parent->color_ = pBlack;
            // Балансировка завершена
            break;
          }
          // Идем балансировать parent
          check_node = parent;
          parent = check_node->parent_;
        } else {
          if (sibling->left_ != nullptr && sibling->left_->color_ == pRed &&
              (sibling->right_ == nullptr ||
               sibling->right_->color_ == pBlack)) {
            // Случай 6.3
            std::swap(sibling->color_, sibling->left_->color_);
            RotateRight(sibling);
            sibling = parent->right_;
          }

          // Случай 6.4
          sibling->right_->color_ = pBlack;
          sibling->color_ = parent->color_;
          parent->color_ = pBlack;
          RotateLeft(parent);
          // Балансировка завершена
          break;
        }
      } else {
        // Удаляемый элемент находится справа от родителя
        tree_node *sibling = parent->left_;

        // Случай 6.1
        if (sibling->color_ == pRed) {
          std::swap(sibling->color_, parent->color_);
          RotateRight(parent);
          parent = check_node->parent_;
          sibling = parent->left_;
        }

        // Случай 6.2
        if (sibling->color_ == pBlack &&
            (sibling->left_ == nullptr || sibling->left_->color_ == pBlack) &&
            (sibling->right_ == nullptr || sibling->right_->color_ == pBlack)) {
          sibling->color_ = pRed;
          if (parent->color_ == pRed) {
            parent->color_ = pBlack;
            // Балансировка завершена
            break;
          }
          // Идем балансировать parent
          check_node = parent;
          parent = check_node->parent_;
        } else {
          if (sibling->right_ != nullptr && sibling->right_->color_ == pRed &&
              (sibling->left_ == nullptr || sibling->left_->color_ == pBlack)) {
            // Случай 6.3
            std::swap(sibling->color_, sibling->right_->color_);
            RotateLeft(sibling);
            sibling = parent->left_;
          }
          // Случай 6.4
          sibling->left_->color_ = pBlack;
          sibling->color_ = parent->color_;
          parent->color_ = pBlack;
          RotateRight(parent);
          // Балансировка завершена
          break;
        }
      }
    }
  }

  /**
   * @brief Находит узел с минимальным значением в дереве.
   *
   * @param node Узел, относительно которого начинается поиск.
   * @return Указатель на узел с минимальным значением.
   *
   * @note В дереве поиска минимальный элемент находится в самом левом узле.
   */
  tree_node *SearchMinimum(tree_node *node) const noexcept {
    while (node->left_ != nullptr) node = node->left_;
    return node;
  }

  /**
   * @brief Находит узел с максимальным значением в дереве.
   *
   * @param node Узел, относительно которого начинается поиск.
   * @return Указатель на узел с максимальным значением.
   *
   * @note В дереве поиска максимальный элемент находится в самом правом узле.
   */
  tree_node *SearchMaximum(tree_node *node) const noexcept {
    while (node->right_ != nullptr) node = node->right_;

    return node;
  }

  /**
   * @brief Вычисляет "черную высоту" узла в дереве.
   *
   * @param node Узел, для которого вычисляется черная высота.
   * @return Черная высота узла, или -1, если дерево не является корректным.
   *
   * @note Черная высота определяется как количество черных узлов на пути от
   * данного узла до самого левого узла. В корректном красно-черном дереве,
   * черная высота всех листьев (узлов без детей) должна быть одинаковой.
   */
  int ComputeBlackHeight(const tree_node *node) const noexcept {
    if (node == nullptr) return 0;

    int left_height = ComputerBlackHeight(node->left_);
    int right_height = ComputerBlackHeight(node->right_);
    int add = node->color_ == pBlack ? 1 : 0;

    // Возвращает -1, если дерево не является корректным:
    // 1) Если левое поддерево не является корректным
    // 2) Если правое поддерево не является корректным
    // 3) Если черная высота левого поддерева не равна высоте правого
    if (left_height == -1 || right_height == -1 || left_height != right_height)
      return -1;
    else
      return left_height + add;
  }

  /**
   * @brief Проверяет свойство красно-черного дерева: каждый красный узел имеет
   * черных детей.
   *
   * @param Node Узел, который проверяется на соответствие свойству
   * красно-черного дерева.
   * @return true, если все красные узлы имеют черных детей, иначе false.
   *
   * @note Этот метод рекурсивно проверяет каждый узел в дереве, начиная с
   * заданного узла. Если найден красный узел с красным потомком, метод
   * возвращает false, указывая на нарушение свойства красно-черного дерева.
   */
  bool CheckRedNodes(const tree_node *Node) const noexcept {
    if (Node->color_ == pRed) {
      if (Node->left_ != nullptr && Node->left_->color_ == pRed) return false;
      if (Node->right_ != nullptr && Node->right_->color_ == pRed) return false;
    }

    if (Node->left_ != nullptr) {
      if (CheckRedNodes(Node->left_) == false) return false;
    }

    if (Node->right_ != nullptr) {
      if (CheckRedNodes(Node->right_) == false) return false;
    }

    return true;
  }

 private:
  struct RedBlackTreeNode {
    /**
     * @brief Конструктор по умолчанию для узла.
     *
     * Инициализирует узел с пустыми ссылками на левый и правый потомки,
     * ключом по умолчанию и красным цветом.
     */
    RedBlackTreeNode()
        : parent_(nullptr),
          left_(this),
          right_(this),
          key_(key_type{}),
          color_(pRed) {}

    /**
     * @brief Конструктор для узла с заданным ключом.
     *
     * @param key Ключ, который будет присвоен узлу.
     *
     * Инициализирует узел с заданным ключом, пустыми ссылками на левый и правый
     * потомки и красным цветом.
     */
    RedBlackTreeNode(const key_type &key)
        : parent_(nullptr),
          left_(nullptr),
          right_(nullptr),
          key_(key),
          color_(pRed) {}

    /**
     * @brief Конструктор для узла с заданным ключом, использующим перемещение.
     *
     * @param key Ключ, который будет перемещен в узел.
     *
     * Инициализирует узел с перемещенным ключом, пустыми ссылками на левый и
     * правый потомки и красным цветом.
     */
    RedBlackTreeNode(key_type &&key)
        : parent_(nullptr),
          left_(nullptr),
          right_(nullptr),
          key_(std::move(key)),
          color_(pRed) {}

    RedBlackTreeNode(key_type key, tree_color color)
        : parent_(nullptr),
          left_(nullptr),
          right_(nullptr),
          key_(key),
          color_(color) {}

    /**
     * @brief Сброс узла к значениям по умолчанию.
     *
     * Сбрасывает ссылки на левый и правый потомки, родителя и цвет узла.
     *
     * @note Метод не выбрасывает исключения.
     */
    void ToDefault() noexcept {
      left_ = nullptr;
      right_ = nullptr;
      parent_ = nullptr;
      color_ = pRed;
    }

    /**
     * @brief Получение следующего узла в порядке обхода дерева.
     *
     * @return Указатель на следующий узел в порядке обхода дерева.
     *
     * @note Метод не выбрасывает исключения.
     */
    tree_node *NextNode() const noexcept {
      tree_node *node = const_cast<tree_node *>(this);
      if (node->color_ == pRed &&
          (node->parent_ == nullptr || node->parent_->parent_ == node)) {
        node = node->left_;
      } else if (node->right_ != nullptr) {
        node = node->right_;
        while (node->left_ != nullptr) node = node->left_;
      } else {
        tree_node *parent = node->parent_;

        while (node == parent->right_) {
          node = parent;
          parent = parent->parent_;
        }

        if (node->right_ != parent) node = parent;
      }

      return node;
    }

    /**
     * @brief Получение предыдущего узла в порядке обхода дерева.
     *
     * @return Указатель на предыдущий узел в порядке обхода дерева.
     *
     * @note Метод не выбрасывает исключения.
     */
    tree_node *PrevNode() const noexcept {
      tree_node *node = const_cast<tree_node *>(this);
      if (node->color_ == pRed &&
          (node->parent_ == nullptr || node->parent_->parent_ == node)) {
        node = node->right_;
      } else if (node->left_ != nullptr) {
        node = node->left_;
        while (node->right_ != nullptr) node = node->right_;
      } else {
        tree_node *parent = node->parent_;
        while (node == parent->left_) {
          node = parent;
          parent = parent_;
        }

        if (node->left_ != parent) node = parent;
      }

      return node;
    }

    tree_node *parent_;  // Указатель на родительский узел.
    tree_node *left_;   // Указатель на левый потомок.
    tree_node *right_;  // Указатель на правый потомок.
    key_type key_;      // Ключ узла.
    tree_color color_;  // Цвет узла.
  };

  struct RedBlackTreeIterator {
    // Типы, используемые в итераторе
    using tree_iterator = std::forward_iterator_tag;  // Категория итератора
    using difference_type =
        std::ptrdiff_t;  // Тип разницы между двумя итераторами
    using value_type =
        tree_type::key_type;  // Тип значения, на который указывает итератор
    using pointer = value_type *;  // Тип указателя на значение
    using reference = value_type &;  // Тип ссылки на значение

    /**
     * @brief Конструктор по умолчанию для итератора.
     *
     * Удален, чтобы предотвратить создание неинициализированного итератора.
     */
    RedBlackTreeIterator() = delete;

    /**
     * @brief Конструктор для итератора, принимающий указатель на узел дерева.
     *
     * @param node Указатель на узел дерева, к которому должен указывать
     * итератор.
     */
    explicit RedBlackTreeIterator(tree_node *node) : node_(node) {}

    /**
     * @brief Оператор разыменования для итератора.
     *
     * @return Ссылку на ключ узла, на который указывает итератор.
     *
     * @note Метод не выбрасывает исключения.
     */
    reference operator*() const noexcept { return node_->key_; }

    /**
     * @brief Префиксный инкремент итератора.
     *
     * @return Ссылку на итератор после его инкремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    iterator &operator++() noexcept {
      node_ = node_->NextNode();
      return *this;
    }

    /**
     * @brief Постфиксный инкремент итератора.
     *
     * @return Копию итератора до его инкремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    iterator operator++(int) noexcept {
      iterator tmp{node_};
      ++(*this);
      return tmp;
    }

    /**
     * @brief Постфиксный декремент итератора.
     *
     * @return Копию итератора до его декремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    iterator &operator--() noexcept {
      node_ = node_->PrevNode();
      return *this;
    }

    /**
     * @brief Префиксный декремент итератора.
     *
     * @return Ссылку на итератор после его декремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    iterator operator--(int) noexcept {
      iterator tmp{node_};
      --(*this);
      return tmp;
    }

    /**
     * @brief Оператор сравнения на равенство для итераторов.
     *
     * @param other Другой итератор для сравнения.
     * @return true, если итераторы указывают на один и тот же узел, и false в
     * противном случае.
     *
     * @note Метод не выбрасывает исключения.
     */
    bool operator==(const iterator &other) const noexcept {
      return node_ == other.node_;
    }

    /**
     * @brief Оператор сравнения на неравенство для итераторов.
     *
     * @param other Другой итератор для сравнения.
     * @return true, если итераторы указывают на разные узлы, и false в
     * противном случае.
     *
     * @note Метод не выбрасывает исключения.
     */
    bool operator!=(const iterator &other) const noexcept {
      return node_ != other.node_;
    }

    tree_node *node_;
  };

  struct RedBlackTreeIteratorConst {
    // Типы, используемые в итераторе
    using iterator_category = std::forward_iterator_tag;  // Категория итератора
    using difference_type =
        std::ptrdiff_t;  // Тип разницы между двумя итераторами
    using value_type =
        tree_type::key_type;  // Тип значения, на который указывает итератор
    using pointer = const value_type *;  // Тип указателя на значение
    using reference = const value_type &;  // Тип ссылки на значение

    /**
     * @brief Конструктор по умолчанию для итератора.
     *
     * Удален, чтобы предотвратить создание неинициализированного итератора.
     */
    RedBlackTreeIteratorConst() = delete;

    /**
     * @brief Конструктор для итератора, принимающий указатель на узел дерева.
     *
     * @param node Указатель на узел дерева, к которому должен указывать
     * итератор.
     */
    explicit RedBlackTreeIteratorConst(const tree_node *node) : node_(node) {}

    /**
     * @brief Конструктор копирования для итератора.
     *
     * @param it Итератор, значение которого должно быть скопировано в новый
     * итератор.
     */
    RedBlackTreeIteratorConst(const iterator &it) : node_(it.node_) {}

    /**
     * @brief Оператор разыменования для итератора.
     *
     * @return Ссылку на ключ узла, на который указывает итератор.
     *
     * @note Метод не выбрасывает исключения.
     */
    reference operator*() const noexcept { return node_->key_; }

    /**
     * @brief Префиксный инкремент итератора.
     *
     * @return Ссылку на итератор после его инкремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    const_iterator &operator++() noexcept {
      node_ = node_->NextNode();
      return *this;
    }

    /**
     * @brief Постфиксный инкремент итератора.
     *
     * @return Копию итератора до его инкремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    const_iterator operator++(int) noexcept {
      const_iterator tmp{node_};
      ++(*this);
      return tmp;
    }

    /**
     * @brief Префиксный декремент итератора.
     *
     * @return Ссылку на итератор после его декремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    const_iterator &operator--() noexcept {
      node_ = node_->PrevNode();
      return *this;
    }

    /**
     * @brief Постфиксный декремент итератора.
     *
     * @return Копию итератора до его декремента.
     *
     * @note Метод не выбрасывает исключения.
     */
    const_iterator operator--(int) noexcept {
      const_iterator tmp{node_};
      --(*this);
      return tmp;
    }

    /**
     * @brief Оператор сравнения на равенство для итераторов.
     *
     * @param it1 Первый итератор для сравнения.
     * @param it2 Второй итератор для сравнения.
     * @return true, если итераторы указывают на один и тот же узел, и false в
     * противном случае.
     *
     * @note Метод не выбрасывает исключения.
     */
    friend bool operator==(const const_iterator &it1,
                           const const_iterator &it2) noexcept {
      return it1.node_ == it2.node_;
    }

    /**
     * @brief Оператор сравнения на неравенство для итераторов.
     *
     * @param it1 Первый итератор для сравнения.
     * @param it2 Второй итератор для сравнения.
     * @return true, если итераторы указывают на разные узлы, и false в
     * противном случае.
     *
     * @note Метод не выбрасывает исключения.
     */
    friend bool operator!=(const const_iterator &it1,
                           const const_iterator &it2) noexcept {
      return it1.node_ != it2.node_;
    }

    // Указатель на узел дерева, к которому указывает итератор.
    const tree_node *node_;
  };

  tree_node *head_;
  size_type size_;
  Comparator cmp_;
};

}  // namespace s21

#endif